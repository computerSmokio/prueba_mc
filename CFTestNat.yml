AWSTemplateFormatVersion: 2010-09-09
Parameters:
  HAPROXYPORT:
    Type: Number
    Default: 80
  APIPORT:
    Type: Number
    Default: 8080
  HAPROXYSTATSPORT:
    Type: Number
    Default: 8081

Mappings:
    AppConfig:
      API:
        PORT: 8080
    SubnetConfig:
      VPC:
        CIDR: "10.0.0.0/16"
      Private:
        CIDR: "10.0.1.0/24"
      Public:
        CIDR: "10.0.0.0/24"
Resources:
  VPC:
    Type: "AWS::EC2::VPC"
    Properties:
      EnableDnsSupport: "true"
      EnableDnsHostnames: "true"
      CidrBlock:
        Fn::FindInMap:
          - "SubnetConfig"
          - "VPC"
          - "CIDR"
  PrivateSubnet:
      Type: "AWS::EC2::Subnet"
      Properties:
        VpcId:
          Ref: "VPC"
        CidrBlock:
          Fn::FindInMap:
            - "SubnetConfig"
            - "Private"
            - "CIDR"
  PrivateRouteTable:
      Type: "AWS::EC2::RouteTable"
      Properties:
        VpcId:
          Ref: "VPC"
  PrivateSubnetRouteTableAssociation:
      Type: "AWS::EC2::SubnetRouteTableAssociation"
      Properties:
        SubnetId:
          Ref: "PrivateSubnet"
        RouteTableId:
          Ref: "PrivateRouteTable"
  PrivateEC2SecurityGroup:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      GroupDescription: Enable NAT instance to access the internet
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !Ref APIPORT
          ToPort: !Ref APIPORT
          SourceSecurityGroupId: !Ref NatInstanceSecurityGroup
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 2049
          ToPort: 2049
          SourceSecurityGroupId:
            - !Ref EFSSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-NAT-SG
   
  PrivateRouteToNAT:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      InstanceId: !Ref EC2NatGateway

  EFSSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable EFS to access the internet
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 2049
          ToPort: 2049
          SourceSecurityGroupId: !Ref PrivateEC2SecurityGroup

  EFSFSEQKW:
    Type: 'AWS::EFS::FileSystem'
    Properties:
      AvailabilityZoneName: { "Fn::GetAtt" : ["PrivateSubnet", "AvailabilityZone"] }

  EFSMountTarget:
    Type: 'AWS::EFS::MountTarget'
    Properties:
      FileSystemId: !Ref EFSFSEQKW
      SubnetId: !Ref PrivateSubnet
      SecurityGroups:
        - !Ref PrivateEC2SecurityGroup

  AutoScalingGroup:
    Type: 'AWS::AutoScaling::AutoScalingGroup'
    Properties:
      LaunchConfigurationName:
        Ref: InstanceLaunchConfig
      MinSize: 1
      MaxSize: 3
      DesiredCapacity: 1
      VPCZoneIdentifier:
        - Ref: PrivateSubnet

  InstanceLaunchConfig:
    Type: 'AWS::AutoScaling::LaunchConfiguration'
    Properties:
      ImageId: 'ami-1853ac65'
      InstanceType: 't2.micro'
      KeyName: matias_admin
      SecurityGroups:
        - !Ref PrivateEC2SecurityGroup
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          yum update -y
          yum install -y docker
          #docker run -v /dev/sdh:/app/data -d -p 8080:8080 --name json-api matiasnv2018/json-api

          # connect to efs and mount it
          yum install -y amazon-efs-utils
          mkdir /mnt/efs
          mount -t nfs ${EFSFSEQKW}:/ /mnt/efs



###### END OF PRIVATE STUFF ######

###### START OF LAMBDA  ######
  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable Lambda to access the internet
      VpcId: !Ref VPC

  LambdaFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      FunctionName: AddServerToHAProxyLambda
      Code: 
        ZipFile: |
          const net = require('net');
          const AWS = require('aws-sdk');

          exports.handler = async (event) => {
              const newServerPort = process.env.NEW_SERVER_PORT;
              const haproxyEndpoint = process.env.HAPROXY_ENDPOINT;
              
              const haproxyBackend = 'app-servers'
              const newServerName = 'new_server'; 
              const instanceId = event.detail['EC2InstanceId'];
              
              const ec2 = new AWS.EC2();
              const instanceDesc = await ec2.describeInstances([instanceId]).promise();
              const newServerIp = instanceDesc.Reservations[0].Instances[0].PrivateIpAddress;
              // Construct the HAProxy stats command to add a new server
              const command = `add server ${haproxyBackend}/${newServerName} ${newServerIp}:${newServerPort}`;
              // Create a socket connection to the HAProxy stats socket
              
              const client = new net.Socket();
              return new Promise((resolve, reject) => {
                  client.connect(haproxyEndpoint, () => {
                      console.log('Connected to HAProxy stats socket');
                      client.write(`${command}\n`);
                  });

                  client.on('data', (data) => {
                      console.log(`Received: ${data}`);
                      client.end();
                      resolve('Server added successfully');
                  });

                  client.on('error', (err) => {
                      console.error(`Error: ${err}`);
                      client.destroy();
                      reject('Error adding server to HAProxy');
                  });
              });
          };
      Runtime: "nodejs14.x"
      Timeout: 30

  LambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service: "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: LambdaExecutionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: "arn:aws:logs:*:*:*"
              - Effect: "Allow"
                Action:
                  - "ec2:DescribeInstances"
                Resource: "*"

  EventRule:
    Type: "AWS::Events::Rule"
    Properties:
      Description: "Trigger Lambda on ASG instance launch"
      EventPattern:
        source:
          - "aws.autoscaling"
        detailType:
          - "EC2 Instance Launch Successful"
        detail:
          AutoScalingGroupName:
            - !Ref AutoScalingGroup
      State: "ENABLED"
      Targets:
        - Arn: !GetAtt LambdaFunction.Arn
          Id: "AddServerToHAProxyLambdaTarget"


###### END OF LAMBDA ######

###### START OF PUBLIC STUFF ######
  NatInstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable NAT instance to access the internet
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !Ref HAPROXYPORT
          ToPort: !Ref HAPROXYPORT
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: !Ref HAPROXYSTATSPORT
          ToPort: !Ref HAPROXYSTATSPORT
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 53
          ToPort: 53
          SourceSecurityGroupId: !Ref PrivateEC2SecurityGroup
        - IpProtocol: udp
          FromPort: 53
          ToPort: 53
          SourceSecurityGroupId: !Ref PrivateEC2SecurityGroup
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-NAT-SG
  PublicSubnet:
    Type: "AWS::EC2::Subnet"
    Properties:
      VpcId:
        Ref: "VPC"
      MapPublicIpOnLaunch: true
      CidrBlock:
        Fn::FindInMap:
          - "SubnetConfig"
          - "Public"
          - "CIDR"
  PublicRouteTable:
      Type: "AWS::EC2::RouteTable"
      Properties:
        VpcId:
          Ref: "VPC"
  PublicSubnetRouteTableAssociation:
      Type: "AWS::EC2::SubnetRouteTableAssociation"
      Properties:
        SubnetId:
          Ref: "PublicSubnet"
        RouteTableId:
          Ref: "PublicRouteTable"
  EC2NatGateway:
    Type: 'AWS::EC2::Instance'
    Properties: 
      InstanceType: 't2.micro'
      ImageId: 'ami-1853ac65'
      KeyName: matias_admin
      SourceDestCheck: false
      SubnetId: 
        Ref: "PublicSubnet"
      SecurityGroupIds:
        - !Ref NatInstanceSecurityGroup
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          echo 1 > /proc/sys/net/ipv4/ip_forward
          /sbin/iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
          /sbin/iptables-save > /etc/sysconfig/iptables
          yum update -y
          yum install -y haproxy
          curl -o /etc/haproxy/haproxy.cfg https://raw.githubusercontent.com/computerSmokio/prueba_mc/feature-nginx-n-dockercompose/loadbalancers/haproxy.cfg?token=GHSAT0AAAAAACJC3GVBPYHXDE6PEGZ3VB7GZKCYSEA
          export HAPROXY_PORT=${HAPROXYPORT}
          export API_PORT=${APIPORT}
          export HAPROXY_STATS_PORT=${HAPROXYSTATSPORT}
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-IGW
  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway
  RouteToInternetGW:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway